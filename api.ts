/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddUserToGroupForm
 */
export interface AddUserToGroupForm {
    /**
     * 
     * @type {number}
     * @memberof AddUserToGroupForm
     */
    'user_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof AddUserToGroupForm
     */
    'group_id'?: number;
}
/**
 * 
 * @export
 * @interface Calendar
 */
export interface Calendar {
    /**
     * 
     * @type {string}
     * @memberof Calendar
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Calendar
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Calendar
     */
    'color'?: string;
}
/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'createTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'updateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'type'?: string;
    /**
     * 
     * @type {Set<Item>}
     * @memberof Category
     */
    'items'?: Set<Item>;
    /**
     * 
     * @type {Set<Task>}
     * @memberof Category
     */
    'tasks'?: Set<Task>;
    /**
     * 
     * @type {Set<Transaction>}
     * @memberof Category
     */
    'transactions'?: Set<Transaction>;
}
/**
 * 
 * @export
 * @interface CategoryDto
 */
export interface CategoryDto {
    /**
     * 
     * @type {number}
     * @memberof CategoryDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CategoryDto
     */
    'createTime': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryDto
     */
    'updateTime': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryDto
     */
    'type': string;
    /**
     * 
     * @type {Set<ItemDto>}
     * @memberof CategoryDto
     */
    'items'?: Set<ItemDto>;
    /**
     * 
     * @type {Set<TaskDto>}
     * @memberof CategoryDto
     */
    'tasks'?: Set<TaskDto>;
}
/**
 * 
 * @export
 * @interface CategoryNoRelationsDto
 */
export interface CategoryNoRelationsDto {
    /**
     * 
     * @type {number}
     * @memberof CategoryNoRelationsDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CategoryNoRelationsDto
     */
    'createTime': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryNoRelationsDto
     */
    'updateTime': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryNoRelationsDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryNoRelationsDto
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface CleaningPlan
 */
export interface CleaningPlan {
    /**
     * 
     * @type {number}
     * @memberof CleaningPlan
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CleaningPlan
     */
    'createTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof CleaningPlan
     */
    'updateTime'?: string;
    /**
     * 
     * @type {Group}
     * @memberof CleaningPlan
     */
    'group'?: Group;
}
/**
 * 
 * @export
 * @interface CreateCategoryDto
 */
export interface CreateCategoryDto {
    /**
     * 
     * @type {string}
     * @memberof CreateCategoryDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCategoryDto
     */
    'type': CreateCategoryDtoTypeEnum;
}

export const CreateCategoryDtoTypeEnum = {
    Cleaning: 'CLEANING',
    Shopping: 'SHOPPING',
    Finance: 'FINANCE',
    Calendar: 'CALENDAR'
} as const;

export type CreateCategoryDtoTypeEnum = typeof CreateCategoryDtoTypeEnum[keyof typeof CreateCategoryDtoTypeEnum];

/**
 * 
 * @export
 * @interface CreateEventDto
 */
export interface CreateEventDto {
    /**
     * 
     * @type {string}
     * @memberof CreateEventDto
     */
    'name': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateEventDto
     */
    'user_ids': Array<number>;
    /**
     * 
     * @type {number}
     * @memberof CreateEventDto
     */
    'category_id': number;
    /**
     * 
     * @type {string}
     * @memberof CreateEventDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventDto
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventDto
     */
    'start': string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventDto
     */
    'end': string;
}
/**
 * 
 * @export
 * @interface CreateGroupDto
 */
export interface CreateGroupDto {
    /**
     * 
     * @type {string}
     * @memberof CreateGroupDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupDto
     */
    'color'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupDto
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupDto
     */
    'street'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupDto
     */
    'zip'?: string;
}
/**
 * 
 * @export
 * @interface CreateItemDto
 */
export interface CreateItemDto {
    /**
     * 
     * @type {string}
     * @memberof CreateItemDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateItemDto
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateItemDto
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof CreateItemDto
     */
    'quantity_type': CreateItemDtoQuantityTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof CreateItemDto
     */
    'done'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CreateItemDto
     */
    'category_id': number;
}

export const CreateItemDtoQuantityTypeEnum = {
    Kilogram: 'KILOGRAM',
    Gram: 'GRAM',
    Liter: 'LITER',
    Milliliter: 'MILLILITER',
    Piece: 'PIECE'
} as const;

export type CreateItemDtoQuantityTypeEnum = typeof CreateItemDtoQuantityTypeEnum[keyof typeof CreateItemDtoQuantityTypeEnum];

/**
 * 
 * @export
 * @interface CreateTaskDto
 */
export interface CreateTaskDto {
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDto
     */
    'description'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateTaskDto
     */
    'user_ids': Array<number>;
    /**
     * 
     * @type {number}
     * @memberof CreateTaskDto
     */
    'category_id': number;
}
/**
 * 
 * @export
 * @interface CreateTransactionDto
 */
export interface CreateTransactionDto {
    /**
     * 
     * @type {number}
     * @memberof CreateTransactionDto
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionDto
     */
    'currency': CreateTransactionDtoCurrencyEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionDto
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateTransactionDto
     */
    'category_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateTransactionDto
     */
    'creditor_id': number;
    /**
     * 
     * @type {number}
     * @memberof CreateTransactionDto
     */
    'debitor_id': number;
}

export const CreateTransactionDtoCurrencyEnum = {
    Eur: 'EUR',
    Usd: 'USD',
    Gbp: 'GBP',
    Chf: 'CHF',
    Jpy: 'JPY',
    Aud: 'AUD',
    Cad: 'CAD',
    Nzd: 'NZD',
    Hkd: 'HKD',
    Sgd: 'SGD',
    Sek: 'SEK',
    Dkk: 'DKK',
    Pln: 'PLN',
    Nok: 'NOK',
    Huf: 'HUF',
    Czk: 'CZK',
    Ils: 'ILS',
    Mxn: 'MXN',
    Brl: 'BRL',
    Myr: 'MYR',
    Rub: 'RUB',
    Thb: 'THB',
    Try: 'TRY',
    Idr: 'IDR',
    Krw: 'KRW',
    Inr: 'INR',
    Php: 'PHP',
    Zar: 'ZAR'
} as const;

export type CreateTransactionDtoCurrencyEnum = typeof CreateTransactionDtoCurrencyEnum[keyof typeof CreateTransactionDtoCurrencyEnum];

/**
 * 
 * @export
 * @interface CreateUserDto
 */
export interface CreateUserDto {
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'firstname': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'lastname': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface EventDto
 */
export interface EventDto {
    /**
     * 
     * @type {string}
     * @memberof EventDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EventDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof EventDto
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDto
     */
    'start': string;
    /**
     * 
     * @type {string}
     * @memberof EventDto
     */
    'end': string;
    /**
     * 
     * @type {Array<UserDto>}
     * @memberof EventDto
     */
    'users'?: Array<UserDto>;
    /**
     * 
     * @type {CategoryNoRelationsDto}
     * @memberof EventDto
     */
    'category'?: CategoryNoRelationsDto;
}
/**
 * 
 * @export
 * @interface Finance
 */
export interface Finance {
    /**
     * 
     * @type {number}
     * @memberof Finance
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Finance
     */
    'createTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Finance
     */
    'updateTime'?: string;
    /**
     * 
     * @type {Group}
     * @memberof Finance
     */
    'group'?: Group;
    /**
     * 
     * @type {Set<Transaction>}
     * @memberof Finance
     */
    'transactions'?: Set<Transaction>;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'createTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'updateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'color'?: string;
    /**
     * 
     * @type {User}
     * @memberof Group
     */
    'owner'?: User;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'street'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'postalCode'?: string;
    /**
     * 
     * @type {ShoppingList}
     * @memberof Group
     */
    'shoppingList'?: ShoppingList;
    /**
     * 
     * @type {CleaningPlan}
     * @memberof Group
     */
    'cleaningPlan'?: CleaningPlan;
    /**
     * 
     * @type {Finance}
     * @memberof Group
     */
    'finance'?: Finance;
    /**
     * 
     * @type {Set<User>}
     * @memberof Group
     */
    'users'?: Set<User>;
    /**
     * 
     * @type {Set<Invitation>}
     * @memberof Group
     */
    'invitations'?: Set<Invitation>;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'eveCalendarId'?: string;
}
/**
 * 
 * @export
 * @interface GroupDto
 */
export interface GroupDto {
    /**
     * 
     * @type {number}
     * @memberof GroupDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GroupDto
     */
    'createTime': string;
    /**
     * 
     * @type {string}
     * @memberof GroupDto
     */
    'updateTime': string;
    /**
     * 
     * @type {string}
     * @memberof GroupDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GroupDto
     */
    'color': string;
    /**
     * 
     * @type {string}
     * @memberof GroupDto
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof GroupDto
     */
    'street': string;
    /**
     * 
     * @type {string}
     * @memberof GroupDto
     */
    'postalCode': string;
}
/**
 * 
 * @export
 * @interface Invitation
 */
export interface Invitation {
    /**
     * 
     * @type {number}
     * @memberof Invitation
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Invitation
     */
    'createTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invitation
     */
    'updateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invitation
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invitation
     */
    'expirationDate'?: string;
    /**
     * 
     * @type {Group}
     * @memberof Invitation
     */
    'livingGroup'?: Group;
}
/**
 * 
 * @export
 * @interface InvitationDto
 */
export interface InvitationDto {
    /**
     * 
     * @type {number}
     * @memberof InvitationDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof InvitationDto
     */
    'createTime': string;
    /**
     * 
     * @type {string}
     * @memberof InvitationDto
     */
    'updateTime': string;
    /**
     * 
     * @type {string}
     * @memberof InvitationDto
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof InvitationDto
     */
    'expirationDate'?: string;
}
/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'createTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'updateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'quantityType'?: string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'done'?: string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'itemscol'?: string;
    /**
     * 
     * @type {Category}
     * @memberof Item
     */
    'category'?: Category;
}
/**
 * 
 * @export
 * @interface ItemDto
 */
export interface ItemDto {
    /**
     * 
     * @type {CategoryNoRelationsDto}
     * @memberof ItemDto
     */
    'category': CategoryNoRelationsDto;
    /**
     * 
     * @type {number}
     * @memberof ItemDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ItemDto
     */
    'createTime': string;
    /**
     * 
     * @type {string}
     * @memberof ItemDto
     */
    'updateTime': string;
    /**
     * 
     * @type {string}
     * @memberof ItemDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ItemDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ItemDto
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof ItemDto
     */
    'quantityType': string;
    /**
     * 
     * @type {string}
     * @memberof ItemDto
     */
    'done': string;
}
/**
 * 
 * @export
 * @interface LoginForm
 */
export interface LoginForm {
    /**
     * 
     * @type {string}
     * @memberof LoginForm
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginForm
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface ModelFile
 */
export interface ModelFile {
    /**
     * 
     * @type {number}
     * @memberof ModelFile
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'createTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'updateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'originalName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface ModifyUserDto
 */
export interface ModifyUserDto {
    /**
     * 
     * @type {string}
     * @memberof ModifyUserDto
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModifyUserDto
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModifyUserDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModifyUserDto
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface ShoppingList
 */
export interface ShoppingList {
    /**
     * 
     * @type {number}
     * @memberof ShoppingList
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShoppingList
     */
    'createTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingList
     */
    'updateTime'?: string;
    /**
     * 
     * @type {Set<Item>}
     * @memberof ShoppingList
     */
    'items'?: Set<Item>;
}
/**
 * 
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'createTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'updateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'recurrenceRule'?: string;
    /**
     * 
     * @type {CleaningPlan}
     * @memberof Task
     */
    'cleaningPlan'?: CleaningPlan;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'done'?: string;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'currentOrderNumber'?: number;
    /**
     * 
     * @type {Set<TasksHasUser>}
     * @memberof Task
     */
    'taskHasUsers'?: Set<TasksHasUser>;
    /**
     * 
     * @type {Category}
     * @memberof Task
     */
    'category'?: Category;
}
/**
 * 
 * @export
 * @interface TaskDto
 */
export interface TaskDto {
    /**
     * 
     * @type {number}
     * @memberof TaskDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TaskDto
     */
    'createTime': string;
    /**
     * 
     * @type {string}
     * @memberof TaskDto
     */
    'updateTime': string;
    /**
     * 
     * @type {string}
     * @memberof TaskDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TaskDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskDto
     */
    'recurrenceRule'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskDto
     */
    'done': string;
    /**
     * 
     * @type {number}
     * @memberof TaskDto
     */
    'currentOrderNumber'?: number;
    /**
     * 
     * @type {Array<TasksHasUserDto>}
     * @memberof TaskDto
     */
    'taskHasUser': Array<TasksHasUserDto>;
    /**
     * 
     * @type {CategoryNoRelationsDto}
     * @memberof TaskDto
     */
    'category': CategoryNoRelationsDto;
}
/**
 * 
 * @export
 * @interface TasksHasUser
 */
export interface TasksHasUser {
    /**
     * 
     * @type {TasksHasUserId}
     * @memberof TasksHasUser
     */
    'id'?: TasksHasUserId;
    /**
     * 
     * @type {Task}
     * @memberof TasksHasUser
     */
    'task'?: Task;
    /**
     * 
     * @type {User}
     * @memberof TasksHasUser
     */
    'user'?: User;
    /**
     * 
     * @type {number}
     * @memberof TasksHasUser
     */
    'orderNumber'?: number;
}
/**
 * 
 * @export
 * @interface TasksHasUserDto
 */
export interface TasksHasUserDto {
    /**
     * 
     * @type {UserDto}
     * @memberof TasksHasUserDto
     */
    'user'?: UserDto;
    /**
     * 
     * @type {number}
     * @memberof TasksHasUserDto
     */
    'orderNumber'?: number;
}
/**
 * 
 * @export
 * @interface TasksHasUserId
 */
export interface TasksHasUserId {
    /**
     * 
     * @type {number}
     * @memberof TasksHasUserId
     */
    'tasksId'?: number;
    /**
     * 
     * @type {number}
     * @memberof TasksHasUserId
     */
    'usersId'?: number;
}
/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'createTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'updateTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'type'?: string;
    /**
     * 
     * @type {User}
     * @memberof Transaction
     */
    'user'?: User;
    /**
     * 
     * @type {User}
     * @memberof Transaction
     */
    'creditor'?: User;
    /**
     * 
     * @type {User}
     * @memberof Transaction
     */
    'debitor'?: User;
    /**
     * 
     * @type {Finance}
     * @memberof Transaction
     */
    'finance'?: Finance;
    /**
     * 
     * @type {Category}
     * @memberof Transaction
     */
    'category'?: Category;
}
/**
 * 
 * @export
 * @interface TransactionDto
 */
export interface TransactionDto {
    /**
     * 
     * @type {number}
     * @memberof TransactionDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionDto
     */
    'createTime': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDto
     */
    'updateTime': string;
    /**
     * 
     * @type {number}
     * @memberof TransactionDto
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionDto
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDto
     */
    'description': string;
    /**
     * 
     * @type {CategoryNoRelationsDto}
     * @memberof TransactionDto
     */
    'category'?: CategoryNoRelationsDto;
    /**
     * 
     * @type {UserDto}
     * @memberof TransactionDto
     */
    'user'?: UserDto;
    /**
     * 
     * @type {UserDto}
     * @memberof TransactionDto
     */
    'debitor': UserDto;
    /**
     * 
     * @type {UserDto}
     * @memberof TransactionDto
     */
    'creditor': UserDto;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username'?: string;
    /**
     * 
     * @type {Group}
     * @memberof User
     */
    'group'?: Group;
    /**
     * 
     * @type {Set<TasksHasUser>}
     * @memberof User
     */
    'userHasTasks'?: Set<TasksHasUser>;
}
/**
 * 
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * 
     * @type {number}
     * @memberof UserDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'createTime': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'updateTime': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'email': string;
    /**
     * 
     * @type {GroupDto}
     * @memberof UserDto
     */
    'group'?: GroupDto;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {LoginForm} loginForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginForm: LoginForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginForm' is not null or undefined
            assertParamExists('login', 'loginForm', loginForm)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginForm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (createUserDto: CreateUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserDto' is not null or undefined
            assertParamExists('register', 'createUserDto', createUserDto)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {LoginForm} loginForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginForm: LoginForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginForm, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.login']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(createUserDto: CreateUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(createUserDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.register']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {LoginForm} loginForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginForm: LoginForm, options?: any): AxiosPromise<string> {
            return localVarFp.login(loginForm, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(createUserDto: CreateUserDto, options?: any): AxiosPromise<User> {
            return localVarFp.register(createUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {LoginForm} loginForm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(loginForm: LoginForm, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).login(loginForm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateUserDto} createUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public register(createUserDto: CreateUserDto, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).register(createUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CalendarApi - axios parameter creator
 * @export
 */
export const CalendarApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ModelString} groupId 
         * @param {CreateEventDto} createEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (groupId: ModelString, createEventDto: CreateEventDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('createEvent', 'groupId', groupId)
            // verify required parameter 'createEventDto' is not null or undefined
            assertParamExists('createEvent', 'createEventDto', createEventDto)
            const localVarPath = `/groups/{group_id}/calendar/events`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ModelString} groupId 
         * @param {ModelString} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent: async (groupId: ModelString, eventId: ModelString, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteEvent', 'groupId', groupId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('deleteEvent', 'eventId', eventId)
            const localVarPath = `/groups/{group_id}/calendar/events/{event_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ModelString} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalendar: async (groupId: ModelString, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getCalendar', 'groupId', groupId)
            const localVarPath = `/groups/{group_id}/calendar`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ModelString} groupId 
         * @param {string} start 
         * @param {string} end 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsBetween: async (groupId: ModelString, start: string, end: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getEventsBetween', 'groupId', groupId)
            // verify required parameter 'start' is not null or undefined
            assertParamExists('getEventsBetween', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('getEventsBetween', 'end', end)
            const localVarPath = `/groups/{group_id}/calendar/events`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CalendarApi - functional programming interface
 * @export
 */
export const CalendarApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CalendarApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ModelString} groupId 
         * @param {CreateEventDto} createEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(groupId: ModelString, createEventDto: CreateEventDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(groupId, createEventDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CalendarApi.createEvent']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {ModelString} groupId 
         * @param {ModelString} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEvent(groupId: ModelString, eventId: ModelString, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEvent(groupId, eventId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CalendarApi.deleteEvent']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {ModelString} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCalendar(groupId: ModelString, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Calendar>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCalendar(groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CalendarApi.getCalendar']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {ModelString} groupId 
         * @param {string} start 
         * @param {string} end 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventsBetween(groupId: ModelString, start: string, end: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventsBetween(groupId, start, end, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CalendarApi.getEventsBetween']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * CalendarApi - factory interface
 * @export
 */
export const CalendarApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CalendarApiFp(configuration)
    return {
        /**
         * 
         * @param {ModelString} groupId 
         * @param {CreateEventDto} createEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(groupId: ModelString, createEventDto: CreateEventDto, options?: any): AxiosPromise<EventDto> {
            return localVarFp.createEvent(groupId, createEventDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ModelString} groupId 
         * @param {ModelString} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent(groupId: ModelString, eventId: ModelString, options?: any): AxiosPromise<string> {
            return localVarFp.deleteEvent(groupId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ModelString} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalendar(groupId: ModelString, options?: any): AxiosPromise<Calendar> {
            return localVarFp.getCalendar(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ModelString} groupId 
         * @param {string} start 
         * @param {string} end 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsBetween(groupId: ModelString, start: string, end: string, options?: any): AxiosPromise<Array<EventDto>> {
            return localVarFp.getEventsBetween(groupId, start, end, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CalendarApi - object-oriented interface
 * @export
 * @class CalendarApi
 * @extends {BaseAPI}
 */
export class CalendarApi extends BaseAPI {
    /**
     * 
     * @param {ModelString} groupId 
     * @param {CreateEventDto} createEventDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarApi
     */
    public createEvent(groupId: ModelString, createEventDto: CreateEventDto, options?: AxiosRequestConfig) {
        return CalendarApiFp(this.configuration).createEvent(groupId, createEventDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ModelString} groupId 
     * @param {ModelString} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarApi
     */
    public deleteEvent(groupId: ModelString, eventId: ModelString, options?: AxiosRequestConfig) {
        return CalendarApiFp(this.configuration).deleteEvent(groupId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ModelString} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarApi
     */
    public getCalendar(groupId: ModelString, options?: AxiosRequestConfig) {
        return CalendarApiFp(this.configuration).getCalendar(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ModelString} groupId 
     * @param {string} start 
     * @param {string} end 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarApi
     */
    public getEventsBetween(groupId: ModelString, start: string, end: string, options?: AxiosRequestConfig) {
        return CalendarApiFp(this.configuration).getEventsBetween(groupId, start, end, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CategoryApi - axios parameter creator
 * @export
 */
export const CategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateCategoryDto} createCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory: async (createCategoryDto: CreateCategoryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCategoryDto' is not null or undefined
            assertParamExists('createCategory', 'createCategoryDto', createCategoryDto)
            const localVarPath = `/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCategoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetCategoriesByTypeTypeEnum} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesByType: async (type: GetCategoriesByTypeTypeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getCategoriesByType', 'type', type)
            const localVarPath = `/categories/type/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryApi - functional programming interface
 * @export
 */
export const CategoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateCategoryDto} createCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCategory(createCategoryDto: CreateCategoryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCategory(createCategoryDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CategoryApi.createCategory']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {GetCategoriesByTypeTypeEnum} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoriesByType(type: GetCategoriesByTypeTypeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CategoryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoriesByType(type, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CategoryApi.getCategoriesByType']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * CategoryApi - factory interface
 * @export
 */
export const CategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoryApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateCategoryDto} createCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory(createCategoryDto: CreateCategoryDto, options?: any): AxiosPromise<CategoryDto> {
            return localVarFp.createCategory(createCategoryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetCategoriesByTypeTypeEnum} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesByType(type: GetCategoriesByTypeTypeEnum, options?: any): AxiosPromise<Array<CategoryDto>> {
            return localVarFp.getCategoriesByType(type, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoryApi - object-oriented interface
 * @export
 * @class CategoryApi
 * @extends {BaseAPI}
 */
export class CategoryApi extends BaseAPI {
    /**
     * 
     * @param {CreateCategoryDto} createCategoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public createCategory(createCategoryDto: CreateCategoryDto, options?: AxiosRequestConfig) {
        return CategoryApiFp(this.configuration).createCategory(createCategoryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetCategoriesByTypeTypeEnum} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public getCategoriesByType(type: GetCategoriesByTypeTypeEnum, options?: AxiosRequestConfig) {
        return CategoryApiFp(this.configuration).getCategoriesByType(type, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetCategoriesByTypeTypeEnum = {
    Cleaning: 'CLEANING',
    Shopping: 'SHOPPING',
    Finance: 'FINANCE',
    Calendar: 'CALENDAR'
} as const;
export type GetCategoriesByTypeTypeEnum = typeof GetCategoriesByTypeTypeEnum[keyof typeof GetCategoriesByTypeTypeEnum];


/**
 * FileControllerApi - axios parameter creator
 * @export
 */
export const FileControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} groupId 
         * @param {ModelFile} modelFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile: async (groupId: string, modelFile: ModelFile, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('createFile', 'groupId', groupId)
            // verify required parameter 'modelFile' is not null or undefined
            assertParamExists('createFile', 'modelFile', modelFile)
            const localVarPath = `/groups/{group_id}/files`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modelFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {ModelFile} modelFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: async (groupId: string, modelFile: ModelFile, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteFile', 'groupId', groupId)
            // verify required parameter 'modelFile' is not null or undefined
            assertParamExists('deleteFile', 'modelFile', modelFile)
            const localVarPath = `/groups/{group_id}/files`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modelFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFiles: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getAllFiles', 'groupId', groupId)
            const localVarPath = `/groups/{group_id}/files`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {ModelFile} modelFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFile: async (groupId: string, modelFile: ModelFile, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateFile', 'groupId', groupId)
            // verify required parameter 'modelFile' is not null or undefined
            assertParamExists('updateFile', 'modelFile', modelFile)
            const localVarPath = `/groups/{group_id}/files`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modelFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileControllerApi - functional programming interface
 * @export
 */
export const FileControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FileControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} groupId 
         * @param {ModelFile} modelFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFile(groupId: string, modelFile: ModelFile, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFile(groupId, modelFile, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FileControllerApi.createFile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupId 
         * @param {ModelFile} modelFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFile(groupId: string, modelFile: ModelFile, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(groupId, modelFile, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FileControllerApi.deleteFile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllFiles(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllFiles(groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FileControllerApi.getAllFiles']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupId 
         * @param {ModelFile} modelFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFile(groupId: string, modelFile: ModelFile, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFile(groupId, modelFile, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FileControllerApi.updateFile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * FileControllerApi - factory interface
 * @export
 */
export const FileControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} groupId 
         * @param {ModelFile} modelFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile(groupId: string, modelFile: ModelFile, options?: any): AxiosPromise<any> {
            return localVarFp.createFile(groupId, modelFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {ModelFile} modelFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(groupId: string, modelFile: ModelFile, options?: any): AxiosPromise<string> {
            return localVarFp.deleteFile(groupId, modelFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFiles(groupId: string, options?: any): AxiosPromise<Array<any>> {
            return localVarFp.getAllFiles(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {ModelFile} modelFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFile(groupId: string, modelFile: ModelFile, options?: any): AxiosPromise<any> {
            return localVarFp.updateFile(groupId, modelFile, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FileControllerApi - object-oriented interface
 * @export
 * @class FileControllerApi
 * @extends {BaseAPI}
 */
export class FileControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} groupId 
     * @param {ModelFile} modelFile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileControllerApi
     */
    public createFile(groupId: string, modelFile: ModelFile, options?: AxiosRequestConfig) {
        return FileControllerApiFp(this.configuration).createFile(groupId, modelFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupId 
     * @param {ModelFile} modelFile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileControllerApi
     */
    public deleteFile(groupId: string, modelFile: ModelFile, options?: AxiosRequestConfig) {
        return FileControllerApiFp(this.configuration).deleteFile(groupId, modelFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileControllerApi
     */
    public getAllFiles(groupId: string, options?: AxiosRequestConfig) {
        return FileControllerApiFp(this.configuration).getAllFiles(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupId 
     * @param {ModelFile} modelFile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileControllerApi
     */
    public updateFile(groupId: string, modelFile: ModelFile, options?: AxiosRequestConfig) {
        return FileControllerApiFp(this.configuration).updateFile(groupId, modelFile, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GroupApi - axios parameter creator
 * @export
 */
export const GroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateGroupDto} createGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: async (createGroupDto: CreateGroupDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createGroupDto' is not null or undefined
            assertParamExists('createGroup', 'createGroupDto', createGroupDto)
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGroupDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGroup', 'id', id)
            const localVarPath = `/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsers', 'id', id)
            const localVarPath = `/groups/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupApi - functional programming interface
 * @export
 */
export const GroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateGroupDto} createGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroup(createGroupDto: CreateGroupDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroup(createGroupDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupApi.createGroup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroup(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroup(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupApi.getGroup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupApi.getUsers']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * GroupApi - factory interface
 * @export
 */
export const GroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateGroupDto} createGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(createGroupDto: CreateGroupDto, options?: any): AxiosPromise<Group> {
            return localVarFp.createGroup(createGroupDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(id: string, options?: any): AxiosPromise<Group> {
            return localVarFp.getGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(id: string, options?: any): AxiosPromise<Array<UserDto>> {
            return localVarFp.getUsers(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupApi - object-oriented interface
 * @export
 * @class GroupApi
 * @extends {BaseAPI}
 */
export class GroupApi extends BaseAPI {
    /**
     * 
     * @param {CreateGroupDto} createGroupDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public createGroup(createGroupDto: CreateGroupDto, options?: AxiosRequestConfig) {
        return GroupApiFp(this.configuration).createGroup(createGroupDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public getGroup(id: string, options?: AxiosRequestConfig) {
        return GroupApiFp(this.configuration).getGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public getUsers(id: string, options?: AxiosRequestConfig) {
        return GroupApiFp(this.configuration).getUsers(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InvitationApi - axios parameter creator
 * @export
 */
export const InvitationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvitation: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('acceptInvitation', 'token', token)
            const localVarPath = `/invitation/accept/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvitation: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('createInvitation', 'groupId', groupId)
            const localVarPath = `/groups/{group_id}/invitation`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvitations: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getInvitations', 'groupId', groupId)
            const localVarPath = `/groups/{group_id}/invitation`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvitationApi - functional programming interface
 * @export
 */
export const InvitationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvitationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptInvitation(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptInvitation(token, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvitationApi.acceptInvitation']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvitation(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvitationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInvitation(groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvitationApi.createInvitation']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvitations(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InvitationDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvitations(groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvitationApi.getInvitations']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * InvitationApi - factory interface
 * @export
 */
export const InvitationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvitationApiFp(configuration)
    return {
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvitation(token: string, options?: any): AxiosPromise<string> {
            return localVarFp.acceptInvitation(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvitation(groupId: string, options?: any): AxiosPromise<InvitationDto> {
            return localVarFp.createInvitation(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvitations(groupId: string, options?: any): AxiosPromise<Array<InvitationDto>> {
            return localVarFp.getInvitations(groupId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvitationApi - object-oriented interface
 * @export
 * @class InvitationApi
 * @extends {BaseAPI}
 */
export class InvitationApi extends BaseAPI {
    /**
     * 
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public acceptInvitation(token: string, options?: AxiosRequestConfig) {
        return InvitationApiFp(this.configuration).acceptInvitation(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public createInvitation(groupId: string, options?: AxiosRequestConfig) {
        return InvitationApiFp(this.configuration).createInvitation(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public getInvitations(groupId: string, options?: AxiosRequestConfig) {
        return InvitationApiFp(this.configuration).getInvitations(groupId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemApi - axios parameter creator
 * @export
 */
export const ItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} groupId 
         * @param {CreateItemDto} createItemDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem: async (groupId: string, createItemDto: CreateItemDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('createItem', 'groupId', groupId)
            // verify required parameter 'createItemDto' is not null or undefined
            assertParamExists('createItem', 'createItemDto', createItemDto)
            const localVarPath = `/groups/{group_id}/shopping/items`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem: async (id: number, groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItem', 'id', id)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteItem', 'groupId', groupId)
            const localVarPath = `/groups/{group_id}/shopping/items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem: async (id: string, groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItem', 'id', id)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getItem', 'groupId', groupId)
            const localVarPath = `/groups/{group_id}/shopping/items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getItems', 'groupId', groupId)
            const localVarPath = `/groups/{group_id}/shopping/items`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {Item} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem: async (groupId: string, item: Item, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateItem', 'groupId', groupId)
            // verify required parameter 'item' is not null or undefined
            assertParamExists('updateItem', 'item', item)
            const localVarPath = `/groups/{group_id}/shopping/items`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(item, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemApi - functional programming interface
 * @export
 */
export const ItemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} groupId 
         * @param {CreateItemDto} createItemDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItem(groupId: string, createItemDto: CreateItemDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItem(groupId, createItemDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ItemApi.createItem']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItem(id: number, groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItem(id, groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ItemApi.deleteItem']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItem(id: string, groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItem(id, groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ItemApi.getItem']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItems(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ItemDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItems(groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ItemApi.getItems']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupId 
         * @param {Item} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItem(groupId: string, item: Item, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateItem(groupId, item, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ItemApi.updateItem']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ItemApi - factory interface
 * @export
 */
export const ItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemApiFp(configuration)
    return {
        /**
         * 
         * @param {string} groupId 
         * @param {CreateItemDto} createItemDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem(groupId: string, createItemDto: CreateItemDto, options?: any): AxiosPromise<ItemDto> {
            return localVarFp.createItem(groupId, createItemDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem(id: number, groupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItem(id, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem(id: string, groupId: string, options?: any): AxiosPromise<ItemDto> {
            return localVarFp.getItem(id, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems(groupId: string, options?: any): AxiosPromise<Array<ItemDto>> {
            return localVarFp.getItems(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {Item} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(groupId: string, item: Item, options?: any): AxiosPromise<Item> {
            return localVarFp.updateItem(groupId, item, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemApi - object-oriented interface
 * @export
 * @class ItemApi
 * @extends {BaseAPI}
 */
export class ItemApi extends BaseAPI {
    /**
     * 
     * @param {string} groupId 
     * @param {CreateItemDto} createItemDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public createItem(groupId: string, createItemDto: CreateItemDto, options?: AxiosRequestConfig) {
        return ItemApiFp(this.configuration).createItem(groupId, createItemDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public deleteItem(id: number, groupId: string, options?: AxiosRequestConfig) {
        return ItemApiFp(this.configuration).deleteItem(id, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public getItem(id: string, groupId: string, options?: AxiosRequestConfig) {
        return ItemApiFp(this.configuration).getItem(id, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public getItems(groupId: string, options?: AxiosRequestConfig) {
        return ItemApiFp(this.configuration).getItems(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupId 
     * @param {Item} item 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public updateItem(groupId: string, item: Item, options?: AxiosRequestConfig) {
        return ItemApiFp(this.configuration).updateItem(groupId, item, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TaskApi - axios parameter creator
 * @export
 */
export const TaskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} groupId 
         * @param {CreateTaskDto} createTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTask: async (groupId: string, createTaskDto: CreateTaskDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('createTask', 'groupId', groupId)
            // verify required parameter 'createTaskDto' is not null or undefined
            assertParamExists('createTask', 'createTaskDto', createTaskDto)
            const localVarPath = `/groups/{group_id}/cleaning/tasks`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTaskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask: async (id: number, groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTask', 'id', id)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteTask', 'groupId', groupId)
            const localVarPath = `/groups/{group_id}/cleaning/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskById: async (id: number, groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTaskById', 'id', id)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getTaskById', 'groupId', groupId)
            const localVarPath = `/groups/{group_id}/cleaning/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getTasks', 'groupId', groupId)
            const localVarPath = `/groups/{group_id}/cleaning/tasks`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} groupId 
         * @param {Task} task 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask: async (id: number, groupId: string, task: Task, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTask', 'id', id)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateTask', 'groupId', groupId)
            // verify required parameter 'task' is not null or undefined
            assertParamExists('updateTask', 'task', task)
            const localVarPath = `/groups/{group_id}/cleaning/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(task, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskApi - functional programming interface
 * @export
 */
export const TaskApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaskApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} groupId 
         * @param {CreateTaskDto} createTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTask(groupId: string, createTaskDto: CreateTaskDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTask(groupId, createTaskDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TaskApi.createTask']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTask(id: number, groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTask(id, groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TaskApi.deleteTask']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskById(id: number, groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskById(id, groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TaskApi.getTaskById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTasks(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTasks(groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TaskApi.getTasks']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} groupId 
         * @param {Task} task 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTask(id: number, groupId: string, task: Task, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTask(id, groupId, task, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TaskApi.updateTask']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TaskApi - factory interface
 * @export
 */
export const TaskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaskApiFp(configuration)
    return {
        /**
         * 
         * @param {string} groupId 
         * @param {CreateTaskDto} createTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTask(groupId: string, createTaskDto: CreateTaskDto, options?: any): AxiosPromise<TaskDto> {
            return localVarFp.createTask(groupId, createTaskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask(id: number, groupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTask(id, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskById(id: number, groupId: string, options?: any): AxiosPromise<Task> {
            return localVarFp.getTaskById(id, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks(groupId: string, options?: any): AxiosPromise<Array<TaskDto>> {
            return localVarFp.getTasks(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} groupId 
         * @param {Task} task 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask(id: number, groupId: string, task: Task, options?: any): AxiosPromise<Task> {
            return localVarFp.updateTask(id, groupId, task, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaskApi - object-oriented interface
 * @export
 * @class TaskApi
 * @extends {BaseAPI}
 */
export class TaskApi extends BaseAPI {
    /**
     * 
     * @param {string} groupId 
     * @param {CreateTaskDto} createTaskDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public createTask(groupId: string, createTaskDto: CreateTaskDto, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).createTask(groupId, createTaskDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public deleteTask(id: number, groupId: string, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).deleteTask(id, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getTaskById(id: number, groupId: string, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).getTaskById(id, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getTasks(groupId: string, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).getTasks(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} groupId 
     * @param {Task} task 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public updateTask(id: number, groupId: string, task: Task, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).updateTask(id, groupId, task, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactionApi - axios parameter creator
 * @export
 */
export const TransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} groupId 
         * @param {CreateTransactionDto} createTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction: async (groupId: string, createTransactionDto: CreateTransactionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('createTransaction', 'groupId', groupId)
            // verify required parameter 'createTransactionDto' is not null or undefined
            assertParamExists('createTransaction', 'createTransactionDto', createTransactionDto)
            const localVarPath = `/groups/{group_id}/finance/transactions`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTransactionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction: async (id: number, groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTransaction', 'id', id)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteTransaction', 'groupId', groupId)
            const localVarPath = `/groups/{group_id}/finance/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction: async (id: string, groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTransaction', 'id', id)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getTransaction', 'groupId', groupId)
            const localVarPath = `/groups/{group_id}/finance/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getTransactions', 'groupId', groupId)
            const localVarPath = `/groups/{group_id}/finance/transactions`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionApi - functional programming interface
 * @export
 */
export const TransactionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} groupId 
         * @param {CreateTransactionDto} createTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransaction(groupId: string, createTransactionDto: CreateTransactionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransaction(groupId, createTransactionDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionApi.createTransaction']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTransaction(id: number, groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTransaction(id, groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionApi.deleteTransaction']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransaction(id: string, groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransaction(id, groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionApi.getTransaction']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactions(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransactionDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactions(groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionApi.getTransactions']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TransactionApi - factory interface
 * @export
 */
export const TransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionApiFp(configuration)
    return {
        /**
         * 
         * @param {string} groupId 
         * @param {CreateTransactionDto} createTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction(groupId: string, createTransactionDto: CreateTransactionDto, options?: any): AxiosPromise<TransactionDto> {
            return localVarFp.createTransaction(groupId, createTransactionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction(id: number, groupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTransaction(id, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction(id: string, groupId: string, options?: any): AxiosPromise<TransactionDto> {
            return localVarFp.getTransaction(id, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions(groupId: string, options?: any): AxiosPromise<Array<TransactionDto>> {
            return localVarFp.getTransactions(groupId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionApi - object-oriented interface
 * @export
 * @class TransactionApi
 * @extends {BaseAPI}
 */
export class TransactionApi extends BaseAPI {
    /**
     * 
     * @param {string} groupId 
     * @param {CreateTransactionDto} createTransactionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public createTransaction(groupId: string, createTransactionDto: CreateTransactionDto, options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).createTransaction(groupId, createTransactionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public deleteTransaction(id: number, groupId: string, options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).deleteTransaction(id, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public getTransaction(id: string, groupId: string, options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).getTransaction(id, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public getTransactions(groupId: string, options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).getTransactions(groupId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddUserToGroupForm} addUserToGroupForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToGroup: async (addUserToGroupForm: AddUserToGroupForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addUserToGroupForm' is not null or undefined
            assertParamExists('addUserToGroup', 'addUserToGroupForm', addUserToGroupForm)
            const localVarPath = `/user/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addUserToGroupForm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ModifyUserDto} modifyUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyUser: async (modifyUserDto: ModifyUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modifyUserDto' is not null or undefined
            assertParamExists('modifyUser', 'modifyUserDto', modifyUserDto)
            const localVarPath = `/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modifyUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddUserToGroupForm} addUserToGroupForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserToGroup(addUserToGroupForm: AddUserToGroupForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserToGroup(addUserToGroupForm, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.addUserToGroup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.getUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {ModifyUserDto} modifyUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyUser(modifyUserDto: ModifyUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyUser(modifyUserDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.modifyUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {AddUserToGroupForm} addUserToGroupForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToGroup(addUserToGroupForm: AddUserToGroupForm, options?: any): AxiosPromise<UserDto> {
            return localVarFp.addUserToGroup(addUserToGroupForm, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any): AxiosPromise<UserDto> {
            return localVarFp.getUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ModifyUserDto} modifyUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyUser(modifyUserDto: ModifyUserDto, options?: any): AxiosPromise<UserDto> {
            return localVarFp.modifyUser(modifyUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {AddUserToGroupForm} addUserToGroupForm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public addUserToGroup(addUserToGroupForm: AddUserToGroupForm, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).addUserToGroup(addUserToGroupForm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ModifyUserDto} modifyUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public modifyUser(modifyUserDto: ModifyUserDto, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).modifyUser(modifyUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}



