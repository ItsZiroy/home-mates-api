/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddUserToGroupForm
 */
export interface AddUserToGroupForm {
    /**
     * 
     * @type {number}
     * @memberof AddUserToGroupForm
     */
    'user_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof AddUserToGroupForm
     */
    'group_id'?: number;
}
/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'createTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'updateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'type'?: string;
    /**
     * 
     * @type {Set<Item>}
     * @memberof Category
     */
    'items'?: Set<Item>;
    /**
     * 
     * @type {Set<Task>}
     * @memberof Category
     */
    'tasks'?: Set<Task>;
}
/**
 * 
 * @export
 * @interface CategoryDto
 */
export interface CategoryDto {
    /**
     * 
     * @type {number}
     * @memberof CategoryDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CategoryDto
     */
    'createTime': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryDto
     */
    'updateTime': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryDto
     */
    'type': string;
    /**
     * 
     * @type {Set<ItemDto>}
     * @memberof CategoryDto
     */
    'items'?: Set<ItemDto>;
    /**
     * 
     * @type {Set<TaskDto>}
     * @memberof CategoryDto
     */
    'tasks'?: Set<TaskDto>;
}
/**
 * 
 * @export
 * @interface CleaningPlan
 */
export interface CleaningPlan {
    /**
     * 
     * @type {number}
     * @memberof CleaningPlan
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CleaningPlan
     */
    'createTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof CleaningPlan
     */
    'updateTime'?: string;
    /**
     * 
     * @type {Group}
     * @memberof CleaningPlan
     */
    'group'?: Group;
}
/**
 * 
 * @export
 * @interface CreateCategoryDto
 */
export interface CreateCategoryDto {
    /**
     * 
     * @type {string}
     * @memberof CreateCategoryDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCategoryDto
     */
    'type': CreateCategoryDtoTypeEnum;
}

export const CreateCategoryDtoTypeEnum = {
    Cleaning: 'CLEANING',
    Shopping: 'SHOPPING'
} as const;

export type CreateCategoryDtoTypeEnum = typeof CreateCategoryDtoTypeEnum[keyof typeof CreateCategoryDtoTypeEnum];

/**
 * 
 * @export
 * @interface CreateGroupDto
 */
export interface CreateGroupDto {
    /**
     * 
     * @type {string}
     * @memberof CreateGroupDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupDto
     */
    'color'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupDto
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupDto
     */
    'street'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupDto
     */
    'zip'?: string;
}
/**
 * 
 * @export
 * @interface CreateItemDto
 */
export interface CreateItemDto {
    /**
     * 
     * @type {string}
     * @memberof CreateItemDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateItemDto
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateItemDto
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof CreateItemDto
     */
    'quantity_type': CreateItemDtoQuantityTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof CreateItemDto
     */
    'done'?: boolean;
}

export const CreateItemDtoQuantityTypeEnum = {
    Kilogram: 'KILOGRAM',
    Gram: 'GRAM',
    Liter: 'LITER',
    Milliliter: 'MILLILITER',
    Piece: 'PIECE'
} as const;

export type CreateItemDtoQuantityTypeEnum = typeof CreateItemDtoQuantityTypeEnum[keyof typeof CreateItemDtoQuantityTypeEnum];

/**
 * 
 * @export
 * @interface CreateTaskDto
 */
export interface CreateTaskDto {
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDto
     */
    'description'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateTaskDto
     */
    'user_ids': Array<number>;
}
/**
 * 
 * @export
 * @interface CreateUserDto
 */
export interface CreateUserDto {
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'firstname': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'lastname': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Finance
 */
export interface Finance {
    /**
     * 
     * @type {number}
     * @memberof Finance
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Finance
     */
    'createTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Finance
     */
    'updateTime'?: string;
    /**
     * 
     * @type {Group}
     * @memberof Finance
     */
    'group'?: Group;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'createTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'updateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'color'?: string;
    /**
     * 
     * @type {User}
     * @memberof Group
     */
    'owner'?: User;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'street'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'postalCode'?: string;
    /**
     * 
     * @type {ShoppingList}
     * @memberof Group
     */
    'shoppingList'?: ShoppingList;
    /**
     * 
     * @type {CleaningPlan}
     * @memberof Group
     */
    'cleaningPlan'?: CleaningPlan;
    /**
     * 
     * @type {Set<User>}
     * @memberof Group
     */
    'users'?: Set<User>;
    /**
     * 
     * @type {Set<Invitation>}
     * @memberof Group
     */
    'invitations'?: Set<Invitation>;
}
/**
 * 
 * @export
 * @interface GroupDto
 */
export interface GroupDto {
    /**
     * 
     * @type {number}
     * @memberof GroupDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GroupDto
     */
    'createTime': string;
    /**
     * 
     * @type {string}
     * @memberof GroupDto
     */
    'updateTime': string;
    /**
     * 
     * @type {string}
     * @memberof GroupDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GroupDto
     */
    'color': string;
    /**
     * 
     * @type {string}
     * @memberof GroupDto
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof GroupDto
     */
    'street': string;
    /**
     * 
     * @type {string}
     * @memberof GroupDto
     */
    'postalCode': string;
}
/**
 * 
 * @export
 * @interface Invitation
 */
export interface Invitation {
    /**
     * 
     * @type {number}
     * @memberof Invitation
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Invitation
     */
    'createTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invitation
     */
    'updateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invitation
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invitation
     */
    'expirationDate'?: string;
    /**
     * 
     * @type {Group}
     * @memberof Invitation
     */
    'livingGroup'?: Group;
    /**
     * 
     * @type {Group}
     * @memberof Invitation
     */
    'livingGroups'?: Group;
}
/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'createTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'updateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'quantityType'?: string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'done'?: string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'itemscol'?: string;
    /**
     * 
     * @type {Category}
     * @memberof Item
     */
    'category'?: Category;
}
/**
 * 
 * @export
 * @interface ItemDto
 */
export interface ItemDto {
    /**
     * 
     * @type {number}
     * @memberof ItemDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ItemDto
     */
    'createTime': string;
    /**
     * 
     * @type {string}
     * @memberof ItemDto
     */
    'updateTime': string;
    /**
     * 
     * @type {string}
     * @memberof ItemDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ItemDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ItemDto
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof ItemDto
     */
    'quantityType': string;
    /**
     * 
     * @type {string}
     * @memberof ItemDto
     */
    'done': string;
}
/**
 * 
 * @export
 * @interface LoginForm
 */
export interface LoginForm {
    /**
     * 
     * @type {string}
     * @memberof LoginForm
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginForm
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface ModelFile
 */
export interface ModelFile {
    /**
     * 
     * @type {number}
     * @memberof ModelFile
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'createTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'updateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'originalName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface ModifyUserDto
 */
export interface ModifyUserDto {
    /**
     * 
     * @type {string}
     * @memberof ModifyUserDto
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModifyUserDto
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModifyUserDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModifyUserDto
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface ShoppingList
 */
export interface ShoppingList {
    /**
     * 
     * @type {number}
     * @memberof ShoppingList
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShoppingList
     */
    'createTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingList
     */
    'updateTime'?: string;
    /**
     * 
     * @type {Set<Item>}
     * @memberof ShoppingList
     */
    'items'?: Set<Item>;
}
/**
 * 
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'createTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'updateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'recurrenceRule'?: string;
    /**
     * 
     * @type {CleaningPlan}
     * @memberof Task
     */
    'cleaningPlan'?: CleaningPlan;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'done'?: string;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'currentOrderNumber'?: number;
    /**
     * 
     * @type {Set<TasksHasUser>}
     * @memberof Task
     */
    'taskHasUsers'?: Set<TasksHasUser>;
    /**
     * 
     * @type {Category}
     * @memberof Task
     */
    'category'?: Category;
}
/**
 * 
 * @export
 * @interface TaskDto
 */
export interface TaskDto {
    /**
     * 
     * @type {number}
     * @memberof TaskDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TaskDto
     */
    'createTime': string;
    /**
     * 
     * @type {string}
     * @memberof TaskDto
     */
    'updateTime': string;
    /**
     * 
     * @type {string}
     * @memberof TaskDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TaskDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskDto
     */
    'recurrenceRule'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskDto
     */
    'done': string;
    /**
     * 
     * @type {number}
     * @memberof TaskDto
     */
    'currentOrderNumber'?: number;
    /**
     * 
     * @type {Set<TasksHasUserDto>}
     * @memberof TaskDto
     */
    'taskHasUser'?: Set<TasksHasUserDto>;
}
/**
 * 
 * @export
 * @interface TasksHasUser
 */
export interface TasksHasUser {
    /**
     * 
     * @type {TasksHasUserId}
     * @memberof TasksHasUser
     */
    'id'?: TasksHasUserId;
    /**
     * 
     * @type {Task}
     * @memberof TasksHasUser
     */
    'task'?: Task;
    /**
     * 
     * @type {User}
     * @memberof TasksHasUser
     */
    'user'?: User;
    /**
     * 
     * @type {number}
     * @memberof TasksHasUser
     */
    'orderNumber'?: number;
}
/**
 * 
 * @export
 * @interface TasksHasUserDto
 */
export interface TasksHasUserDto {
    /**
     * 
     * @type {UserDto}
     * @memberof TasksHasUserDto
     */
    'user'?: UserDto;
    /**
     * 
     * @type {number}
     * @memberof TasksHasUserDto
     */
    'orderNumber'?: number;
}
/**
 * 
 * @export
 * @interface TasksHasUserId
 */
export interface TasksHasUserId {
    /**
     * 
     * @type {number}
     * @memberof TasksHasUserId
     */
    'tasksId'?: number;
    /**
     * 
     * @type {number}
     * @memberof TasksHasUserId
     */
    'usersId'?: number;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username'?: string;
    /**
     * 
     * @type {Group}
     * @memberof User
     */
    'group'?: Group;
    /**
     * 
     * @type {Set<TasksHasUser>}
     * @memberof User
     */
    'userHasTasks'?: Set<TasksHasUser>;
}
/**
 * 
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * 
     * @type {number}
     * @memberof UserDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'createTime': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'updateTime': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'email': string;
    /**
     * 
     * @type {GroupDto}
     * @memberof UserDto
     */
    'group'?: GroupDto;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {LoginForm} loginForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginForm: LoginForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginForm' is not null or undefined
            assertParamExists('login', 'loginForm', loginForm)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginForm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (createUserDto: CreateUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserDto' is not null or undefined
            assertParamExists('register', 'createUserDto', createUserDto)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {LoginForm} loginForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginForm: LoginForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginForm, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.login']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(createUserDto: CreateUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(createUserDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.register']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {LoginForm} loginForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginForm: LoginForm, options?: any): AxiosPromise<string> {
            return localVarFp.login(loginForm, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(createUserDto: CreateUserDto, options?: any): AxiosPromise<User> {
            return localVarFp.register(createUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {LoginForm} loginForm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(loginForm: LoginForm, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).login(loginForm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateUserDto} createUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public register(createUserDto: CreateUserDto, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).register(createUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CategoryApi - axios parameter creator
 * @export
 */
export const CategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateCategoryDto} createCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory: async (createCategoryDto: CreateCategoryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCategoryDto' is not null or undefined
            assertParamExists('createCategory', 'createCategoryDto', createCategoryDto)
            const localVarPath = `/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCategoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetCategoriesByTypeTypeEnum} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesByType: async (type: GetCategoriesByTypeTypeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getCategoriesByType', 'type', type)
            const localVarPath = `/categories/type/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryApi - functional programming interface
 * @export
 */
export const CategoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateCategoryDto} createCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCategory(createCategoryDto: CreateCategoryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCategory(createCategoryDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CategoryApi.createCategory']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {GetCategoriesByTypeTypeEnum} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoriesByType(type: GetCategoriesByTypeTypeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CategoryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoriesByType(type, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CategoryApi.getCategoriesByType']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * CategoryApi - factory interface
 * @export
 */
export const CategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoryApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateCategoryDto} createCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory(createCategoryDto: CreateCategoryDto, options?: any): AxiosPromise<CategoryDto> {
            return localVarFp.createCategory(createCategoryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetCategoriesByTypeTypeEnum} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesByType(type: GetCategoriesByTypeTypeEnum, options?: any): AxiosPromise<Array<CategoryDto>> {
            return localVarFp.getCategoriesByType(type, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoryApi - object-oriented interface
 * @export
 * @class CategoryApi
 * @extends {BaseAPI}
 */
export class CategoryApi extends BaseAPI {
    /**
     * 
     * @param {CreateCategoryDto} createCategoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public createCategory(createCategoryDto: CreateCategoryDto, options?: AxiosRequestConfig) {
        return CategoryApiFp(this.configuration).createCategory(createCategoryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetCategoriesByTypeTypeEnum} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public getCategoriesByType(type: GetCategoriesByTypeTypeEnum, options?: AxiosRequestConfig) {
        return CategoryApiFp(this.configuration).getCategoriesByType(type, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetCategoriesByTypeTypeEnum = {
    Cleaning: 'CLEANING',
    Shopping: 'SHOPPING'
} as const;
export type GetCategoriesByTypeTypeEnum = typeof GetCategoriesByTypeTypeEnum[keyof typeof GetCategoriesByTypeTypeEnum];


/**
 * FileControllerApi - axios parameter creator
 * @export
 */
export const FileControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} groupId 
         * @param {ModelFile} modelFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile: async (groupId: string, modelFile: ModelFile, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('createFile', 'groupId', groupId)
            // verify required parameter 'modelFile' is not null or undefined
            assertParamExists('createFile', 'modelFile', modelFile)
            const localVarPath = `/groups/{group_id}/files`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modelFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {ModelFile} modelFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: async (groupId: string, modelFile: ModelFile, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteFile', 'groupId', groupId)
            // verify required parameter 'modelFile' is not null or undefined
            assertParamExists('deleteFile', 'modelFile', modelFile)
            const localVarPath = `/groups/{group_id}/files`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modelFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFiles: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getAllFiles', 'groupId', groupId)
            const localVarPath = `/groups/{group_id}/files`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {ModelFile} modelFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFile: async (groupId: string, modelFile: ModelFile, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateFile', 'groupId', groupId)
            // verify required parameter 'modelFile' is not null or undefined
            assertParamExists('updateFile', 'modelFile', modelFile)
            const localVarPath = `/groups/{group_id}/files`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modelFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileControllerApi - functional programming interface
 * @export
 */
export const FileControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FileControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} groupId 
         * @param {ModelFile} modelFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFile(groupId: string, modelFile: ModelFile, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFile(groupId, modelFile, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FileControllerApi.createFile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupId 
         * @param {ModelFile} modelFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFile(groupId: string, modelFile: ModelFile, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(groupId, modelFile, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FileControllerApi.deleteFile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllFiles(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllFiles(groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FileControllerApi.getAllFiles']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupId 
         * @param {ModelFile} modelFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFile(groupId: string, modelFile: ModelFile, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFile(groupId, modelFile, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FileControllerApi.updateFile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * FileControllerApi - factory interface
 * @export
 */
export const FileControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} groupId 
         * @param {ModelFile} modelFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile(groupId: string, modelFile: ModelFile, options?: any): AxiosPromise<any> {
            return localVarFp.createFile(groupId, modelFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {ModelFile} modelFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(groupId: string, modelFile: ModelFile, options?: any): AxiosPromise<string> {
            return localVarFp.deleteFile(groupId, modelFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFiles(groupId: string, options?: any): AxiosPromise<Array<any>> {
            return localVarFp.getAllFiles(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {ModelFile} modelFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFile(groupId: string, modelFile: ModelFile, options?: any): AxiosPromise<any> {
            return localVarFp.updateFile(groupId, modelFile, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FileControllerApi - object-oriented interface
 * @export
 * @class FileControllerApi
 * @extends {BaseAPI}
 */
export class FileControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} groupId 
     * @param {ModelFile} modelFile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileControllerApi
     */
    public createFile(groupId: string, modelFile: ModelFile, options?: AxiosRequestConfig) {
        return FileControllerApiFp(this.configuration).createFile(groupId, modelFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupId 
     * @param {ModelFile} modelFile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileControllerApi
     */
    public deleteFile(groupId: string, modelFile: ModelFile, options?: AxiosRequestConfig) {
        return FileControllerApiFp(this.configuration).deleteFile(groupId, modelFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileControllerApi
     */
    public getAllFiles(groupId: string, options?: AxiosRequestConfig) {
        return FileControllerApiFp(this.configuration).getAllFiles(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupId 
     * @param {ModelFile} modelFile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileControllerApi
     */
    public updateFile(groupId: string, modelFile: ModelFile, options?: AxiosRequestConfig) {
        return FileControllerApiFp(this.configuration).updateFile(groupId, modelFile, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FinanceControllerApi - axios parameter creator
 * @export
 */
export const FinanceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} groupId 
         * @param {Finance} finance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFinance: async (groupId: string, finance: Finance, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('createFinance', 'groupId', groupId)
            // verify required parameter 'finance' is not null or undefined
            assertParamExists('createFinance', 'finance', finance)
            const localVarPath = `/groups/{group_id}/finances`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(finance, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFinance: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteFinance', 'groupId', groupId)
            const localVarPath = `/groups/{group_id}/finances`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFinances: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getAllFinances', 'groupId', groupId)
            const localVarPath = `/groups/{group_id}/finances`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {Finance} finance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFinance: async (groupId: string, finance: Finance, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateFinance', 'groupId', groupId)
            // verify required parameter 'finance' is not null or undefined
            assertParamExists('updateFinance', 'finance', finance)
            const localVarPath = `/groups/{group_id}/finances`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(finance, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FinanceControllerApi - functional programming interface
 * @export
 */
export const FinanceControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FinanceControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} groupId 
         * @param {Finance} finance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFinance(groupId: string, finance: Finance, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Finance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFinance(groupId, finance, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FinanceControllerApi.createFinance']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFinance(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFinance(groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FinanceControllerApi.deleteFinance']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllFinances(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Finance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllFinances(groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FinanceControllerApi.getAllFinances']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupId 
         * @param {Finance} finance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFinance(groupId: string, finance: Finance, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Finance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFinance(groupId, finance, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FinanceControllerApi.updateFinance']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * FinanceControllerApi - factory interface
 * @export
 */
export const FinanceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FinanceControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} groupId 
         * @param {Finance} finance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFinance(groupId: string, finance: Finance, options?: any): AxiosPromise<Finance> {
            return localVarFp.createFinance(groupId, finance, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFinance(groupId: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteFinance(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFinances(groupId: string, options?: any): AxiosPromise<Array<Finance>> {
            return localVarFp.getAllFinances(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {Finance} finance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFinance(groupId: string, finance: Finance, options?: any): AxiosPromise<Finance> {
            return localVarFp.updateFinance(groupId, finance, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FinanceControllerApi - object-oriented interface
 * @export
 * @class FinanceControllerApi
 * @extends {BaseAPI}
 */
export class FinanceControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} groupId 
     * @param {Finance} finance 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinanceControllerApi
     */
    public createFinance(groupId: string, finance: Finance, options?: AxiosRequestConfig) {
        return FinanceControllerApiFp(this.configuration).createFinance(groupId, finance, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinanceControllerApi
     */
    public deleteFinance(groupId: string, options?: AxiosRequestConfig) {
        return FinanceControllerApiFp(this.configuration).deleteFinance(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinanceControllerApi
     */
    public getAllFinances(groupId: string, options?: AxiosRequestConfig) {
        return FinanceControllerApiFp(this.configuration).getAllFinances(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupId 
     * @param {Finance} finance 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinanceControllerApi
     */
    public updateFinance(groupId: string, finance: Finance, options?: AxiosRequestConfig) {
        return FinanceControllerApiFp(this.configuration).updateFinance(groupId, finance, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GroupApi - axios parameter creator
 * @export
 */
export const GroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateGroupDto} createGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: async (createGroupDto: CreateGroupDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createGroupDto' is not null or undefined
            assertParamExists('createGroup', 'createGroupDto', createGroupDto)
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGroupDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGroup', 'id', id)
            const localVarPath = `/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsers', 'id', id)
            const localVarPath = `/groups/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupApi - functional programming interface
 * @export
 */
export const GroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateGroupDto} createGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroup(createGroupDto: CreateGroupDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroup(createGroupDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupApi.createGroup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroup(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroup(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupApi.getGroup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupApi.getUsers']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * GroupApi - factory interface
 * @export
 */
export const GroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateGroupDto} createGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(createGroupDto: CreateGroupDto, options?: any): AxiosPromise<Group> {
            return localVarFp.createGroup(createGroupDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(id: string, options?: any): AxiosPromise<Group> {
            return localVarFp.getGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(id: string, options?: any): AxiosPromise<Array<UserDto>> {
            return localVarFp.getUsers(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupApi - object-oriented interface
 * @export
 * @class GroupApi
 * @extends {BaseAPI}
 */
export class GroupApi extends BaseAPI {
    /**
     * 
     * @param {CreateGroupDto} createGroupDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public createGroup(createGroupDto: CreateGroupDto, options?: AxiosRequestConfig) {
        return GroupApiFp(this.configuration).createGroup(createGroupDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public getGroup(id: string, options?: AxiosRequestConfig) {
        return GroupApiFp(this.configuration).getGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public getUsers(id: string, options?: AxiosRequestConfig) {
        return GroupApiFp(this.configuration).getUsers(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemApi - axios parameter creator
 * @export
 */
export const ItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} groupId 
         * @param {CreateItemDto} createItemDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem: async (groupId: string, createItemDto: CreateItemDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('createItem', 'groupId', groupId)
            // verify required parameter 'createItemDto' is not null or undefined
            assertParamExists('createItem', 'createItemDto', createItemDto)
            const localVarPath = `/groups/{group_id}/shopping/items`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem: async (id: number, groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItem', 'id', id)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteItem', 'groupId', groupId)
            const localVarPath = `/groups/{group_id}/shopping/items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem: async (id: string, groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItem', 'id', id)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getItem', 'groupId', groupId)
            const localVarPath = `/groups/{group_id}/shopping/items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getItems', 'groupId', groupId)
            const localVarPath = `/groups/{group_id}/shopping/items`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {Item} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem: async (groupId: string, item: Item, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateItem', 'groupId', groupId)
            // verify required parameter 'item' is not null or undefined
            assertParamExists('updateItem', 'item', item)
            const localVarPath = `/groups/{group_id}/shopping/items`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(item, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemApi - functional programming interface
 * @export
 */
export const ItemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} groupId 
         * @param {CreateItemDto} createItemDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItem(groupId: string, createItemDto: CreateItemDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItem(groupId, createItemDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ItemApi.createItem']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItem(id: number, groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItem(id, groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ItemApi.deleteItem']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItem(id: string, groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItem(id, groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ItemApi.getItem']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItems(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ItemDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItems(groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ItemApi.getItems']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupId 
         * @param {Item} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItem(groupId: string, item: Item, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateItem(groupId, item, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ItemApi.updateItem']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ItemApi - factory interface
 * @export
 */
export const ItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemApiFp(configuration)
    return {
        /**
         * 
         * @param {string} groupId 
         * @param {CreateItemDto} createItemDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem(groupId: string, createItemDto: CreateItemDto, options?: any): AxiosPromise<ItemDto> {
            return localVarFp.createItem(groupId, createItemDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem(id: number, groupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItem(id, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem(id: string, groupId: string, options?: any): AxiosPromise<ItemDto> {
            return localVarFp.getItem(id, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems(groupId: string, options?: any): AxiosPromise<Array<ItemDto>> {
            return localVarFp.getItems(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {Item} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(groupId: string, item: Item, options?: any): AxiosPromise<Item> {
            return localVarFp.updateItem(groupId, item, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemApi - object-oriented interface
 * @export
 * @class ItemApi
 * @extends {BaseAPI}
 */
export class ItemApi extends BaseAPI {
    /**
     * 
     * @param {string} groupId 
     * @param {CreateItemDto} createItemDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public createItem(groupId: string, createItemDto: CreateItemDto, options?: AxiosRequestConfig) {
        return ItemApiFp(this.configuration).createItem(groupId, createItemDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public deleteItem(id: number, groupId: string, options?: AxiosRequestConfig) {
        return ItemApiFp(this.configuration).deleteItem(id, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public getItem(id: string, groupId: string, options?: AxiosRequestConfig) {
        return ItemApiFp(this.configuration).getItem(id, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public getItems(groupId: string, options?: AxiosRequestConfig) {
        return ItemApiFp(this.configuration).getItems(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupId 
     * @param {Item} item 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public updateItem(groupId: string, item: Item, options?: AxiosRequestConfig) {
        return ItemApiFp(this.configuration).updateItem(groupId, item, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TaskApi - axios parameter creator
 * @export
 */
export const TaskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} groupId 
         * @param {CreateTaskDto} createTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTask: async (groupId: string, createTaskDto: CreateTaskDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('createTask', 'groupId', groupId)
            // verify required parameter 'createTaskDto' is not null or undefined
            assertParamExists('createTask', 'createTaskDto', createTaskDto)
            const localVarPath = `/groups/{group_id}/cleaning/tasks`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTaskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask: async (id: number, groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTask', 'id', id)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteTask', 'groupId', groupId)
            const localVarPath = `/groups/{group_id}/cleaning/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskById: async (id: number, groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTaskById', 'id', id)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getTaskById', 'groupId', groupId)
            const localVarPath = `/groups/{group_id}/cleaning/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getTasks', 'groupId', groupId)
            const localVarPath = `/groups/{group_id}/cleaning/tasks`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} groupId 
         * @param {Task} task 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask: async (id: number, groupId: string, task: Task, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTask', 'id', id)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateTask', 'groupId', groupId)
            // verify required parameter 'task' is not null or undefined
            assertParamExists('updateTask', 'task', task)
            const localVarPath = `/groups/{group_id}/cleaning/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(task, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskApi - functional programming interface
 * @export
 */
export const TaskApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaskApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} groupId 
         * @param {CreateTaskDto} createTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTask(groupId: string, createTaskDto: CreateTaskDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTask(groupId, createTaskDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TaskApi.createTask']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTask(id: number, groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTask(id, groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TaskApi.deleteTask']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskById(id: number, groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskById(id, groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TaskApi.getTaskById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTasks(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTasks(groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TaskApi.getTasks']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} groupId 
         * @param {Task} task 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTask(id: number, groupId: string, task: Task, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTask(id, groupId, task, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TaskApi.updateTask']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TaskApi - factory interface
 * @export
 */
export const TaskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaskApiFp(configuration)
    return {
        /**
         * 
         * @param {string} groupId 
         * @param {CreateTaskDto} createTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTask(groupId: string, createTaskDto: CreateTaskDto, options?: any): AxiosPromise<TaskDto> {
            return localVarFp.createTask(groupId, createTaskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask(id: number, groupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTask(id, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskById(id: number, groupId: string, options?: any): AxiosPromise<Task> {
            return localVarFp.getTaskById(id, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks(groupId: string, options?: any): AxiosPromise<Array<TaskDto>> {
            return localVarFp.getTasks(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} groupId 
         * @param {Task} task 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask(id: number, groupId: string, task: Task, options?: any): AxiosPromise<Task> {
            return localVarFp.updateTask(id, groupId, task, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaskApi - object-oriented interface
 * @export
 * @class TaskApi
 * @extends {BaseAPI}
 */
export class TaskApi extends BaseAPI {
    /**
     * 
     * @param {string} groupId 
     * @param {CreateTaskDto} createTaskDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public createTask(groupId: string, createTaskDto: CreateTaskDto, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).createTask(groupId, createTaskDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public deleteTask(id: number, groupId: string, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).deleteTask(id, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getTaskById(id: number, groupId: string, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).getTaskById(id, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getTasks(groupId: string, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).getTasks(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} groupId 
     * @param {Task} task 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public updateTask(id: number, groupId: string, task: Task, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).updateTask(id, groupId, task, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddUserToGroupForm} addUserToGroupForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToGroup: async (addUserToGroupForm: AddUserToGroupForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addUserToGroupForm' is not null or undefined
            assertParamExists('addUserToGroup', 'addUserToGroupForm', addUserToGroupForm)
            const localVarPath = `/user/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addUserToGroupForm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ModifyUserDto} modifyUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyUser: async (modifyUserDto: ModifyUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modifyUserDto' is not null or undefined
            assertParamExists('modifyUser', 'modifyUserDto', modifyUserDto)
            const localVarPath = `/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modifyUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddUserToGroupForm} addUserToGroupForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserToGroup(addUserToGroupForm: AddUserToGroupForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserToGroup(addUserToGroupForm, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.addUserToGroup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.getUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {ModifyUserDto} modifyUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyUser(modifyUserDto: ModifyUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyUser(modifyUserDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.modifyUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {AddUserToGroupForm} addUserToGroupForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToGroup(addUserToGroupForm: AddUserToGroupForm, options?: any): AxiosPromise<UserDto> {
            return localVarFp.addUserToGroup(addUserToGroupForm, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any): AxiosPromise<UserDto> {
            return localVarFp.getUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ModifyUserDto} modifyUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyUser(modifyUserDto: ModifyUserDto, options?: any): AxiosPromise<UserDto> {
            return localVarFp.modifyUser(modifyUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {AddUserToGroupForm} addUserToGroupForm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public addUserToGroup(addUserToGroupForm: AddUserToGroupForm, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).addUserToGroup(addUserToGroupForm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ModifyUserDto} modifyUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public modifyUser(modifyUserDto: ModifyUserDto, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).modifyUser(modifyUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}



